---
title:  "[DP최적화] Divide and Conquer Optimization"
date:   2019-01-03 00:57:00
categories:
- Hard-Algorithm
tags:
- DP
- DnC-Optimization
---

Divide and Conquer Optimization는 아래 조건을 만족할 때 사용 가능합니다.
* D[t][i] = min(D[t-1][k] + C[k][i]) (단, k < i이다.)
* p[t][i] = D[t][i]의 값이 최소가 되는 k일 때, p[t][i] ≤ p[t][i+1]

D[k][n]을 구할 때, 이 점화식을 naive하게 계산하면 O(KN^2)이 나옵니다.<br>
그러나 두 번째 조건(p[t][i] ≤ p[t][i+1])을 만족한다면, 분할 정복을 이용해 O(KN log N)만에 구할 수 있습니다.

N이 200이고, D[7][1...200]과 D[8][100]의 값을 구해놓았다고 가정합시다. D[7][1...200]과 D[8][100]을 구하면서 p[7][1...200]과 p[8][100]를 구해놓았을 것입니다.

p[t][i] ≤ p[t][i+1]을 만족하기 때문에 D[8][1...99]를 구할 때는 k ≤ p[8][100]인 k에 대해서만 D[7][k] + C[k][i]를 참조하면 되고, 마찬가지로 D[8][101...200]을 구할 때는 k ≥ p[8][100]인 k에 대해서만 D[7][k] + C[k][i]를 참조하면 됩니다.

이러한 점을 이용해 분할 정복을 사용할 수 있습니다.<br>
D[t][l...r]을 구해야 한다면, D[t][(l+r)/2]와 p[t][(l+r)/2]을 먼저 계산한 뒤, D[t][l...(l+r)/2-1]과 D[t][(l+r)/2+1...r]을 구하는 것으로 각각 분할정복을 해주면 됩니다.<br>
t를 고정시키면 각 단계는 O(N log N)에 구할 수 있으며, 총 t단계를 진행하기 때문에 O(TN log N)이 걸립니다.

재귀 함수로 간단하게 구현할 수 있습니다.
```cpp
//D[t][s...e]를 구해야 하고, 탐색 범위는 [l, r]
void f(int t, int s, int e, int l, int r){
  if(s > e) return;
  int m = s + e >> 1;
  int opt = i;
  for(int i=l; i<=r; i++){
    if(D[t-1][opt] + C[opt][m] > D[t-1][i] + C[i][m]) opt = i;
  }
  D[t][m] = D[t-1][opt] + C[opt][m];
  f(s, m-1, l, opt);
  f(m+1, e, opt, r);
}
```

p[t][i] ≤ p[t][i+1]를 만족하는 특별한 부등식이 있습니다.<br>
a < b < c < d일 때 **C[a][c] + C[b][d] < C[a][d] + C[b][c]**를 만족하면 p[t][i] ≤ p[t][i+1]을 만족합니다.<br>
DP로 최솟값이 아닌 최댓값을 구해야 하는 경우, **C[a][c] + C[b][d] > C[a][d] + C[b][c]**를 만족하면 p[t][i] ≤ p[t][i+1]을 만족합니다.<br>
증명은 귀류법으로 할 수 있습니다.
